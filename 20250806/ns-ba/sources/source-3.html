


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>MoMoCompose Coverage Report > MiniXmlPullParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: MoMoCompose<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">vn.momo.compose.payment.promotion.presentation.view.components.htmlrenderer.internal.parser</a>
</div>

<h1>Coverage Summary for Class: MiniXmlPullParser (vn.momo.compose.payment.promotion.presentation.view.components.htmlrenderer.internal.parser)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">MiniXmlPullParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/380)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/439)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2322)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MiniXmlPullParser$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniXmlPullParser$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniXmlPullParser$Companion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/63)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MiniXmlPullParser$WhenMappings</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/384)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/448)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2387)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package vn.momo.compose.payment.promotion.presentation.view.components.htmlrenderer.internal.parser
&nbsp;
&nbsp;import vn.momo.compose.payment.promotion.presentation.view.components.htmlrenderer.internal.parser.api.EventType
&nbsp;import vn.momo.compose.payment.promotion.presentation.view.components.htmlrenderer.internal.parser.api.XmlPullParser
&nbsp;import vn.momo.compose.payment.promotion.presentation.view.components.htmlrenderer.internal.parser.api.XmlPullParserException
&nbsp;
&nbsp;/**
&nbsp; * A simple non-validating xml pull parser.
&nbsp; */
<b class="nc">&nbsp;class MiniXmlPullParser(</b>
<b class="nc">&nbsp;    val source: CharIterator,</b>
<b class="nc">&nbsp;    val processNamespaces: Boolean = false,</b>
<b class="nc">&nbsp;    val relaxed: Boolean = false,</b>
<b class="nc">&nbsp;    val entityResolver: (String) -&gt; String? = { null }</b>
&nbsp;)  : XmlPullParser {
&nbsp;
&nbsp;    constructor(
&nbsp;        source: String,
<b class="nc">&nbsp;        processNamespaces: Boolean = false,</b>
<b class="nc">&nbsp;        relaxed: Boolean = false,</b>
<b class="nc">&nbsp;        entityResolver: (String) -&gt; String? = { null }</b>
<b class="nc">&nbsp;    ) : this(source.iterator(), processNamespaces, relaxed, entityResolver)</b>
&nbsp;
&nbsp;    companion object {
&nbsp;        private const val CARRIAGE_RETURN_CODE = 13
&nbsp;        private const val NEWLINE_CODE = 10
&nbsp;
&nbsp;        private const val UNEXPECTED_EOF = &quot;Unexpected EOF&quot;
&nbsp;
&nbsp;        private fun &lt;T&gt; arraycopy(src: Array&lt;T&gt;, srcPos: Int, dst: Array&lt;T&gt;, dstPos: Int, count: Int) {
<b class="nc">&nbsp;            src.copyInto(dst, dstPos, srcPos, srcPos + count)</b>
&nbsp;        }
&nbsp;
&nbsp;        private fun arraycopy(src: IntArray, srcPos: Int, dst: IntArray, dstPos: Int, count: Int) {
<b class="nc">&nbsp;            src.copyInto(dst, dstPos, srcPos, srcPos + count)</b>
&nbsp;        }
&nbsp;
&nbsp;        private fun arraycopy(src: CharArray, srcPos: Int, dst: CharArray, dstPos: Int, count: Int) {
<b class="nc">&nbsp;            src.copyInto(dst, dstPos, srcPos, srcPos + count)</b>
&nbsp;        }
&nbsp;
&nbsp;        private fun ensureCapacity(arr: Array&lt;String&gt;, required: Int): Array&lt;String&gt; {
<b class="nc">&nbsp;            if (arr.size &gt;= required) return arr</b>
<b class="nc">&nbsp;            val bigger =Array&lt;String&gt;(required + 16) { &quot;&quot; }</b>
<b class="nc">&nbsp;            arraycopy(arr, 0, bigger, 0, arr.size)</b>
<b class="nc">&nbsp;            return bigger</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    // general
&nbsp;
<b class="nc">&nbsp;    override var depth = 0</b>
<b class="nc">&nbsp;    private var elementStack = Array(16) {&quot;&quot;}</b>
<b class="nc">&nbsp;    private var nspStack = Array(16) {&quot;&quot;}</b>
<b class="nc">&nbsp;    private var nspCounts = IntArray(8)</b>
&nbsp;
&nbsp;    private var token = false
&nbsp;    private var unresolved = false
&nbsp;
&nbsp;    // source
&nbsp;
<b class="nc">&nbsp;    override var lineNumber = 1</b>
<b class="nc">&nbsp;    override var columnNumber = 0</b>
&nbsp;
&nbsp;    // text buffer
&nbsp;
<b class="nc">&nbsp;    private var txtBuf = CharArray(128)</b>
&nbsp;    private var txtPos = 0
&nbsp;
&nbsp;    // event-related
&nbsp;
<b class="nc">&nbsp;    override var eventType = EventType.START_DOCUMENT</b>
<b class="nc">&nbsp;    override var isWhitespace = false</b>
<b class="nc">&nbsp;    override var namespace = &quot;&quot;</b>
<b class="nc">&nbsp;    override var prefix = &quot;&quot;</b>
<b class="nc">&nbsp;    override var name = &quot;&quot;</b>
<b class="nc">&nbsp;    override var lastError = &quot;&quot;</b>
&nbsp;
<b class="nc">&nbsp;    override var isEmptyElementTag = false</b>
<b class="nc">&nbsp;    override var attributeCount = 0</b>
&nbsp;
<b class="nc">&nbsp;    private var attributes = Array(16) {&quot;&quot;}</b>
&nbsp;
<b class="nc">&nbsp;    private val peek = IntArray(2)</b>
&nbsp;    private var peekCount = 0
&nbsp;    private var wasCR = false
&nbsp;
&nbsp;    private fun adjustNsp(): Boolean {
<b class="nc">&nbsp;        var any = false</b>
<b class="nc">&nbsp;        var i = 0</b>
<b class="nc">&nbsp;        while (i &lt; attributeCount shl 2) {</b>
&nbsp;
&nbsp;            // * 4 - 4; i &gt;= 0; i -= 4) {
<b class="nc">&nbsp;            var attrName = attributes[i + 2]</b>
<b class="nc">&nbsp;            val cut = attrName.indexOf(&#39;:&#39;)</b>
<b class="nc">&nbsp;            var prefix: String</b>
<b class="nc">&nbsp;            if (cut != -1) {</b>
<b class="nc">&nbsp;                prefix = attrName.substring(0, cut)</b>
<b class="nc">&nbsp;                attrName = attrName.substring(cut + 1)</b>
<b class="nc">&nbsp;            } else if (attrName == &quot;xmlns&quot;) {</b>
<b class="nc">&nbsp;                prefix = attrName</b>
<b class="nc">&nbsp;                attrName = &quot;&quot;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                i += 4</b>
&nbsp;                continue
&nbsp;            }
<b class="nc">&nbsp;            if (prefix != &quot;xmlns&quot;) {</b>
<b class="nc">&nbsp;                any = true</b>
&nbsp;            } else {
<b class="nc">&nbsp;                val j = nspCounts[depth]++ shl 1</b>
<b class="nc">&nbsp;                nspStack = ensureCapacity(nspStack, j + 2)</b>
<b class="nc">&nbsp;                nspStack[j] = attrName</b>
<b class="nc">&nbsp;                nspStack[j + 1] = attributes[i + 3]</b>
<b class="nc">&nbsp;                if (attrName != &quot;&quot; &amp;&amp; attributes[i + 3] == &quot;&quot;) {</b>
<b class="nc">&nbsp;                    error(&quot;illegal empty namespace&quot;)</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                arraycopy(</b>
<b class="nc">&nbsp;                    attributes,</b>
<b class="nc">&nbsp;                    i + 4,</b>
<b class="nc">&nbsp;                    attributes,</b>
<b class="nc">&nbsp;                    i,</b>
<b class="nc">&nbsp;                    (--attributeCount shl 2) - i</b>
&nbsp;                )
<b class="nc">&nbsp;                i -= 4</b>
&nbsp;            }
<b class="nc">&nbsp;            i += 4</b>
&nbsp;        }
<b class="nc">&nbsp;        if (any) {</b>
<b class="nc">&nbsp;            i = (attributeCount shl 2) - 4</b>
<b class="nc">&nbsp;            while (i &gt;= 0) {</b>
<b class="nc">&nbsp;                var attrName = attributes[i + 2]</b>
<b class="nc">&nbsp;                val cut = attrName.indexOf(&#39;:&#39;)</b>
<b class="nc">&nbsp;                if (cut == 0 &amp;&amp; !relaxed) throw exception(</b>
<b class="nc">&nbsp;                    &quot;illegal attribute name: $attrName at $this&quot;</b>
<b class="nc">&nbsp;                ) else if (cut != -1) {</b>
<b class="nc">&nbsp;                    val attrPrefix = attrName.substring(0, cut)</b>
<b class="nc">&nbsp;                    attrName = attrName.substring(cut + 1)</b>
<b class="nc">&nbsp;                    val attrNs = getNamespace(attrPrefix)</b>
<b class="nc">&nbsp;                    if (attrNs == null &amp;&amp; !relaxed) throw exception(</b>
<b class="nc">&nbsp;                        &quot;Undefined Prefix: $attrPrefix in $this&quot;</b>
&nbsp;                    )
<b class="nc">&nbsp;                    attributes[i] = attrNs ?: &quot;&quot;</b>
<b class="nc">&nbsp;                    attributes[i + 1] = attrPrefix</b>
<b class="nc">&nbsp;                    attributes[i + 2] = attrName</b>
&nbsp;                }
<b class="nc">&nbsp;                i -= 4</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        val cut = name.indexOf(&#39;:&#39;)</b>
<b class="nc">&nbsp;        if (cut == 0) error(&quot;illegal tag name: $name&quot;)</b>
<b class="nc">&nbsp;        if (cut != -1) {</b>
<b class="nc">&nbsp;            prefix = name.substring(0, cut)</b>
<b class="nc">&nbsp;            name = name.substring(cut + 1)</b>
&nbsp;        }
<b class="nc">&nbsp;        val namespace = getNamespace(prefix)</b>
<b class="nc">&nbsp;        if (namespace == null &amp;&amp; prefix != &quot;&quot;) {</b>
<b class="nc">&nbsp;            error(&quot;undefined prefix: $prefix&quot;)</b>
&nbsp;        }
<b class="nc">&nbsp;        this.namespace = namespace ?: &quot;&quot;</b>
<b class="nc">&nbsp;        return any</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun error(message: String) {
<b class="nc">&nbsp;        lastError = message</b>
<b class="nc">&nbsp;        if (!relaxed) {</b>
<b class="nc">&nbsp;            throw exception(message)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun exception(message: String): XmlPullParserException {
<b class="nc">&nbsp;        return XmlPullParserException(</b>
<b class="nc">&nbsp;            message, positionDescription, lineNumber, columnNumber</b>
&nbsp;        )
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * common base for next and nextToken. Clears the state, except from
&nbsp;     * txtPos and whitespace. Does not set the type variable
&nbsp;     */
&nbsp;    private fun nextImpl() {
<b class="nc">&nbsp;        if (eventType == EventType.END_TAG) {</b>
<b class="nc">&nbsp;            depth--</b>
&nbsp;        }
<b class="nc">&nbsp;        while (true) {</b>
<b class="nc">&nbsp;            attributeCount = -1</b>
&nbsp;
&nbsp;            // degenerated needs to be handled before error because of possible
&nbsp;            // processor expectations(!)
<b class="nc">&nbsp;            if (isEmptyElementTag) {</b>
<b class="nc">&nbsp;                isEmptyElementTag = false</b>
<b class="nc">&nbsp;                eventType = EventType.END_TAG</b>
&nbsp;                return
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            prefix = &quot;&quot;</b>
<b class="nc">&nbsp;            name = &quot;&quot;</b>
<b class="nc">&nbsp;            namespace = &quot;&quot;</b>
&nbsp;
<b class="nc">&nbsp;            eventType = peekType()</b>
<b class="nc">&nbsp;            when (eventType) {</b>
&nbsp;                EventType.ENTITY_REF -&gt; {
<b class="nc">&nbsp;                    pushEntity()</b>
&nbsp;                    return
&nbsp;                }
&nbsp;                EventType.START_TAG -&gt; {
<b class="nc">&nbsp;                    parseStartTag(false)</b>
&nbsp;                    return
&nbsp;                }
&nbsp;                EventType.END_TAG -&gt; {
<b class="nc">&nbsp;                    parseEndTag()</b>
&nbsp;                    return
&nbsp;                }
&nbsp;                EventType.END_DOCUMENT -&gt; return
&nbsp;                EventType.TEXT -&gt; {
<b class="nc">&nbsp;                    pushText(&#39;&lt;&#39;.code, !token)</b>
<b class="nc">&nbsp;                    if (depth == 0) {</b>
<b class="nc">&nbsp;                        if (isWhitespace) {</b>
<b class="nc">&nbsp;                            eventType = EventType.IGNORABLE_WHITESPACE</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    return
&nbsp;                }
&nbsp;                else -&gt; {
<b class="nc">&nbsp;                    eventType = parseLegacy(token)</b>
&nbsp;                    return
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun parseLegacy(push: Boolean): EventType {
<b class="nc">&nbsp;        var push = push</b>
<b class="nc">&nbsp;        var req = &quot;&quot;</b>
<b class="nc">&nbsp;        val term: Int</b>
<b class="nc">&nbsp;        val result: EventType</b>
<b class="nc">&nbsp;        var prev = 0</b>
<b class="nc">&nbsp;        read() // &lt;</b>
<b class="nc">&nbsp;        var c: Int = read()</b>
<b class="nc">&nbsp;        if (c == &#39;?&#39;.code) {</b>
<b class="nc">&nbsp;            if ((peek(0) == &#39;x&#39;.code || peek(0) == &#39;X&#39;.code)</b>
<b class="nc">&nbsp;                &amp;&amp; (peek(1) == &#39;m&#39;.code || peek(1) == &#39;M&#39;.code)</b>
&nbsp;            ) {
<b class="nc">&nbsp;                if (push) {</b>
<b class="nc">&nbsp;                    push(peek(0))</b>
<b class="nc">&nbsp;                    push(peek(1))</b>
&nbsp;                }
<b class="nc">&nbsp;                read()</b>
<b class="nc">&nbsp;                read()</b>
<b class="nc">&nbsp;                if ((peek(0) == &#39;l&#39;.code || peek(0) == &#39;L&#39;.code) &amp;&amp; peek(1) &lt;= &#39; &#39;.code) {</b>
<b class="nc">&nbsp;                    if (lineNumber != 1 || columnNumber &gt; 4) error(&quot;PI must not start with xml&quot;)</b>
<b class="nc">&nbsp;                    parseStartTag(true)</b>
<b class="nc">&nbsp;                    if (attributeCount &lt; 1 || &quot;version&quot; != attributes[2]) error(&quot;version expected&quot;)</b>
&nbsp;                    //       version = attributes[3]
<b class="nc">&nbsp;                    var pos = 1</b>
<b class="nc">&nbsp;                    if (pos &lt; attributeCount</b>
<b class="nc">&nbsp;                        &amp;&amp; &quot;encoding&quot; == attributes[2 + 4]</b>
&nbsp;                    ) {
&nbsp;                        //         encoding = attributes[3 + 4]
<b class="nc">&nbsp;                        pos++</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (pos &lt; attributeCount</b>
<b class="nc">&nbsp;                        &amp;&amp; &quot;standalone&quot; == attributes[4 * pos + 2]</b>
&nbsp;                    ) {
<b class="nc">&nbsp;                        val st = attributes[3 + 4 * pos]</b>
<b class="nc">&nbsp;                        if (&quot;yes&quot; == st) {</b>
&nbsp;                            // standalone = true
<b class="nc">&nbsp;                        } else if (&quot;no&quot; == st) {</b>
&nbsp;                            // standalone = false
&nbsp;                        } else {
<b class="nc">&nbsp;                            error(&quot;illegal standalone value: $st&quot;)</b>
&nbsp;                        }
<b class="nc">&nbsp;                        pos++</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (pos != attributeCount) error(&quot;illegal xmldecl&quot;)</b>
<b class="nc">&nbsp;                    isWhitespace = true</b>
<b class="nc">&nbsp;                    txtPos = 0</b>
<b class="nc">&nbsp;                    return EventType.XML_DECL</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /*            int c0 = read ();
&nbsp;                        int c1 = read ();
<b class="nc">&nbsp;                        int */term = &#39;?&#39;.code</b>
<b class="nc">&nbsp;            result = EventType.PROCESSING_INSTRUCTION</b>
&nbsp;        } else if (c == &#39;!&#39;.code) {
<b class="nc">&nbsp;            if (peek(0) == &#39;-&#39;.code) {</b>
<b class="nc">&nbsp;                result = EventType.COMMENT</b>
<b class="nc">&nbsp;                req = &quot;--&quot;</b>
<b class="nc">&nbsp;                term = &#39;-&#39;.code</b>
<b class="nc">&nbsp;            } else if (peek(0) == &#39;[&#39;.code) {</b>
<b class="nc">&nbsp;                result = EventType.CDSECT</b>
<b class="nc">&nbsp;                req = &quot;[CDATA[&quot;</b>
<b class="nc">&nbsp;                term = &#39;]&#39;.code</b>
<b class="nc">&nbsp;                push = true</b>
&nbsp;            } else {
<b class="nc">&nbsp;                result = EventType.DOCDECL</b>
<b class="nc">&nbsp;                req = &quot;DOCTYPE&quot;</b>
<b class="nc">&nbsp;                term = -1</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            error(&quot;illegal: &lt;$c&quot;)</b>
<b class="nc">&nbsp;            return EventType.COMMENT</b>
&nbsp;        }
<b class="nc">&nbsp;        for (i in 0 until req.length) read(req[i])</b>
<b class="nc">&nbsp;        if (result == EventType.DOCDECL) parseDoctype(push) else {</b>
<b class="nc">&nbsp;            while (true) {</b>
<b class="nc">&nbsp;                c = read()</b>
<b class="nc">&nbsp;                if (c == -1) {</b>
<b class="nc">&nbsp;                    error(UNEXPECTED_EOF)</b>
<b class="nc">&nbsp;                    return EventType.COMMENT</b>
&nbsp;                }
<b class="nc">&nbsp;                if (push) push(c)</b>
<b class="nc">&nbsp;                if ((term == &#39;?&#39;.code || c == term)</b>
<b class="nc">&nbsp;                    &amp;&amp; peek(0) == term &amp;&amp; peek(1) == &#39;&gt;&#39;.code</b>
&nbsp;                ) break
<b class="nc">&nbsp;                prev = c</b>
&nbsp;            }
<b class="nc">&nbsp;            if (term == &#39;-&#39;.code &amp;&amp; prev == &#39;-&#39;.code &amp;&amp; !relaxed) error(&quot;illegal comment delimiter: ---&gt;&quot;)</b>
<b class="nc">&nbsp;            read()</b>
<b class="nc">&nbsp;            read()</b>
<b class="nc">&nbsp;            if (push &amp;&amp; term != &#39;?&#39;.code) txtPos--</b>
&nbsp;        }
<b class="nc">&nbsp;        return result</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /** precondition: &amp;lt! consumed  */
&nbsp;    private fun parseDoctype(push: Boolean) {
<b class="nc">&nbsp;        var nesting = 1</b>
<b class="nc">&nbsp;        var quoted = false</b>
&nbsp;
&nbsp;        // read();
<b class="nc">&nbsp;        while (true) {</b>
<b class="nc">&nbsp;            val i: Int = read()</b>
<b class="nc">&nbsp;            when (i) {</b>
&nbsp;                -1 -&gt; {
<b class="nc">&nbsp;                    error(UNEXPECTED_EOF)</b>
&nbsp;                    return
&nbsp;                }
<b class="nc">&nbsp;                &#39;\&#39;&#39;.code -&gt; quoted = !quoted</b>
<b class="nc">&nbsp;                &#39;&lt;&#39;.code -&gt; if (!quoted) nesting++</b>
<b class="nc">&nbsp;                &#39;&gt;&#39;.code -&gt; if (!quoted) {</b>
<b class="nc">&nbsp;                    if (--nesting == 0) return</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (push) push(i)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /* precondition: &amp;lt;/ consumed */
&nbsp;    private fun parseEndTag() {
<b class="nc">&nbsp;        read() // &#39;&lt;&#39;</b>
<b class="nc">&nbsp;        read() // &#39;/&#39;</b>
<b class="nc">&nbsp;        name = readName()</b>
<b class="nc">&nbsp;        skip()</b>
<b class="nc">&nbsp;        read(&#39;&gt;&#39;)</b>
<b class="nc">&nbsp;        val sp = depth - 1 shl 2</b>
<b class="nc">&nbsp;        if (depth == 0) {</b>
<b class="nc">&nbsp;            error(&quot;element stack empty&quot;)</b>
<b class="nc">&nbsp;            eventType = EventType.COMMENT</b>
&nbsp;            return
&nbsp;        }
<b class="nc">&nbsp;        if (!relaxed) {</b>
<b class="nc">&nbsp;            if (name != elementStack[sp + 3]) {</b>
<b class="nc">&nbsp;                error(&quot;expected: /&quot; + elementStack[sp + 3] + &quot; read: &quot; + name)</b>
&nbsp;
&nbsp;                // become case insensitive in relaxed mode
&nbsp;
&nbsp;//            int probe = sp;
&nbsp;//            while (probe &gt;= 0 &amp;&amp; !name.toLowerCase().equals(elementStack[probe + 3].toLowerCase())) {
&nbsp;//                stackMismatch++;
&nbsp;//                probe -= 4;
&nbsp;//            }
&nbsp;//
&nbsp;//            if (probe &lt; 0) {
&nbsp;//                stackMismatch = 0;
&nbsp;//                //			text = &quot;unexpected end tag ignored&quot;;
&nbsp;//                eventType = COMMENT;
&nbsp;//                return;
&nbsp;//            }
&nbsp;            }
<b class="nc">&nbsp;            namespace = elementStack[sp]</b>
<b class="nc">&nbsp;            prefix = elementStack[sp + 1]</b>
<b class="nc">&nbsp;            name = elementStack[sp + 2]</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private fun peekType(): EventType {
<b class="nc">&nbsp;        return when (peek(0)) {</b>
<b class="nc">&nbsp;            -1 -&gt; EventType.END_DOCUMENT</b>
<b class="nc">&nbsp;            &#39;&amp;&#39;.code -&gt; EventType.ENTITY_REF</b>
<b class="nc">&nbsp;            &#39;&lt;&#39;.code -&gt; when (peek(1)) {</b>
<b class="nc">&nbsp;                &#39;/&#39;.code -&gt; EventType.END_TAG</b>
&nbsp;                // Could be XML_DECL, too, but doesn&#39;t matter here.
<b class="nc">&nbsp;                &#39;?&#39;.code -&gt; EventType.PROCESSING_INSTRUCTION</b>
<b class="nc">&nbsp;                &#39;!&#39;.code -&gt; if (peek(1) == &#39;-&#39;.code) {</b>
<b class="nc">&nbsp;                    EventType.COMMENT</b>
<b class="nc">&nbsp;                } else if (peek(1) == &#39;[&#39;.code) {</b>
<b class="nc">&nbsp;                    EventType.CDSECT</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    EventType.DOCDECL</b>
&nbsp;                }
<b class="nc">&nbsp;                else -&gt; EventType.START_TAG</b>
&nbsp;            }
<b class="nc">&nbsp;            else -&gt; EventType.TEXT</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun get(pos: Int): String {
<b class="nc">&nbsp;        return txtBuf.concatToString(pos, txtPos)</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun push(c: Int) {
<b class="nc">&nbsp;        isWhitespace = isWhitespace and (c &lt;= &#39; &#39;.code)</b>
<b class="nc">&nbsp;        if (txtPos + 1 &gt;= txtBuf.size) { // +1 to have enough space for 2 surrogates, if needed</b>
<b class="nc">&nbsp;            val bigger = CharArray(txtPos * 4 / 3 + 4)</b>
<b class="nc">&nbsp;            arraycopy(txtBuf, 0, bigger, 0, txtPos)</b>
<b class="nc">&nbsp;            txtBuf = bigger</b>
&nbsp;        }
<b class="nc">&nbsp;        if (c &gt; 0xffff) {</b>
&nbsp;            // write high Unicode value as surrogate pair
<b class="nc">&nbsp;            val offset = c - 0x010000</b>
<b class="nc">&nbsp;            txtBuf[txtPos++] = ((offset ushr 10) + 0xd800).toChar() // high surrogate</b>
<b class="nc">&nbsp;            txtBuf[txtPos++] = ((offset and 0x3ff) + 0xdc00).toChar() // low surrogate</b>
&nbsp;        } else {
<b class="nc">&nbsp;            txtBuf[txtPos++] = c.toChar()</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Sets name and attributes  */
&nbsp;    private fun parseStartTag(xmldecl: Boolean) {
<b class="nc">&nbsp;        if (!xmldecl) read()</b>
<b class="nc">&nbsp;        name = readName()</b>
<b class="nc">&nbsp;        attributeCount = 0</b>
<b class="nc">&nbsp;        while (true) {</b>
<b class="nc">&nbsp;            skip()</b>
<b class="nc">&nbsp;            val c = peek(0)</b>
<b class="nc">&nbsp;            if (xmldecl) {</b>
<b class="nc">&nbsp;                if (c == &#39;?&#39;.code) {</b>
<b class="nc">&nbsp;                    read()</b>
<b class="nc">&nbsp;                    read(&#39;&gt;&#39;)</b>
&nbsp;                    return
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (c == &#39;/&#39;.code) {</b>
<b class="nc">&nbsp;                    isEmptyElementTag = true</b>
<b class="nc">&nbsp;                    read()</b>
<b class="nc">&nbsp;                    skip()</b>
<b class="nc">&nbsp;                    read(&#39;&gt;&#39;)</b>
&nbsp;                    break
&nbsp;                }
<b class="nc">&nbsp;                if (c == &#39;&gt;&#39;.code &amp;&amp; !xmldecl) {</b>
<b class="nc">&nbsp;                    read()</b>
&nbsp;                    break
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (c == -1) {</b>
<b class="nc">&nbsp;                error(UNEXPECTED_EOF)</b>
&nbsp;                return
&nbsp;            }
<b class="nc">&nbsp;            val attrName = readName()</b>
<b class="nc">&nbsp;            if (attrName.length == 0) {</b>
<b class="nc">&nbsp;                error(&quot;attr name expected&quot;)</b>
&nbsp;                break
&nbsp;            }
<b class="nc">&nbsp;            var i = attributeCount++ shl 2</b>
<b class="nc">&nbsp;            attributes = ensureCapacity(attributes, i + 4)</b>
<b class="nc">&nbsp;            attributes[i++] = &quot;&quot;</b>
<b class="nc">&nbsp;            attributes[i++] = &quot;&quot;</b>
<b class="nc">&nbsp;            attributes[i++] = attrName</b>
<b class="nc">&nbsp;            skip()</b>
<b class="nc">&nbsp;            if (peek(0) != &#39;=&#39;.code) {</b>
<b class="nc">&nbsp;                if (!relaxed) {</b>
<b class="nc">&nbsp;                    error(&quot;Attr.value missing f. $attrName&quot;)</b>
&nbsp;                }
<b class="nc">&nbsp;                attributes[i] = attrName</b>
&nbsp;            } else {
<b class="nc">&nbsp;                read(&#39;=&#39;)</b>
<b class="nc">&nbsp;                skip()</b>
<b class="nc">&nbsp;                var delimiter = peek(0)</b>
<b class="nc">&nbsp;                if (delimiter != &#39;\&#39;&#39;.code &amp;&amp; delimiter != &#39;&quot;&#39;.code) {</b>
<b class="nc">&nbsp;                    if (!relaxed) {</b>
<b class="nc">&nbsp;                        error(&quot;attr value delimiter missing!&quot;)</b>
&nbsp;                    }
<b class="nc">&nbsp;                    delimiter = &#39; &#39;.code</b>
<b class="nc">&nbsp;                } else read()</b>
<b class="nc">&nbsp;                val p = txtPos</b>
<b class="nc">&nbsp;                pushText(delimiter, true)</b>
<b class="nc">&nbsp;                attributes[i] = get(p)</b>
<b class="nc">&nbsp;                txtPos = p</b>
<b class="nc">&nbsp;                if (delimiter != &#39; &#39;.code) read() // skip endquote</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        val sp = depth++ shl 2</b>
<b class="nc">&nbsp;        elementStack = ensureCapacity(elementStack, sp + 4)</b>
<b class="nc">&nbsp;        elementStack[sp + 3] = name</b>
<b class="nc">&nbsp;        if (depth &gt;= nspCounts.size) {</b>
<b class="nc">&nbsp;            val bigger = IntArray(depth + 4)</b>
<b class="nc">&nbsp;            arraycopy(nspCounts, 0, bigger, 0, nspCounts.size)</b>
<b class="nc">&nbsp;            nspCounts = bigger</b>
&nbsp;        }
<b class="nc">&nbsp;        nspCounts[depth] = nspCounts[depth - 1]</b>
&nbsp;
<b class="nc">&nbsp;        if (processNamespaces) {</b>
<b class="nc">&nbsp;            adjustNsp()</b>
&nbsp;        } else {
<b class="nc">&nbsp;            namespace = &quot;&quot;</b>
&nbsp;        }
<b class="nc">&nbsp;        elementStack[sp] = namespace</b>
<b class="nc">&nbsp;        elementStack[sp + 1] = prefix</b>
<b class="nc">&nbsp;        elementStack[sp + 2] = name</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * result: isWhitespace; if the setName parameter is set,
&nbsp;     * the name of the entity is stored in &quot;name&quot;
&nbsp;     */
&nbsp;    private fun pushEntity() {
<b class="nc">&nbsp;        push(read()) // &amp;</b>
<b class="nc">&nbsp;        val pos = txtPos</b>
<b class="nc">&nbsp;        while (true) {</b>
<b class="nc">&nbsp;            val c = peek(0)</b>
<b class="nc">&nbsp;            if (c == &#39;;&#39;.code) {</b>
<b class="nc">&nbsp;                read()</b>
&nbsp;                break
&nbsp;            }
<b class="nc">&nbsp;            if (c &lt; 128 &amp;&amp; (c &lt; &#39;0&#39;.code || c &gt; &#39;9&#39;.code)</b>
<b class="nc">&nbsp;                &amp;&amp; (c &lt; &#39;a&#39;.code || c &gt; &#39;z&#39;.code)</b>
<b class="nc">&nbsp;                &amp;&amp; (c &lt; &#39;A&#39;.code || c &gt; &#39;Z&#39;.code)</b>
<b class="nc">&nbsp;                &amp;&amp; c != &#39;_&#39;.code &amp;&amp; c != &#39;-&#39;.code &amp;&amp; c != &#39;#&#39;.code</b>
&nbsp;            ) {
<b class="nc">&nbsp;                if (!relaxed) {</b>
<b class="nc">&nbsp;                    error(&quot;unterminated entity ref&quot;)</b>
&nbsp;                }
<b class="nc">&nbsp;                println(&quot;broken entitiy: &quot; + get(pos - 1))</b>
&nbsp;
&nbsp;                //; ends with:&quot;+(char)c);
&nbsp;//                if (c != -1)
&nbsp;//                    push(c);
&nbsp;                return
&nbsp;            }
<b class="nc">&nbsp;            push(read())</b>
&nbsp;        }
<b class="nc">&nbsp;        val code = get(pos)</b>
<b class="nc">&nbsp;        txtPos = pos - 1</b>
<b class="nc">&nbsp;        if (token &amp;&amp; eventType === EventType.ENTITY_REF) {</b>
<b class="nc">&nbsp;            name = code</b>
&nbsp;        }
<b class="nc">&nbsp;        if (code[0] == &#39;#&#39;) {</b>
<b class="nc">&nbsp;            val c = if (code[1] == &#39;x&#39;) code.substring(2).toInt(16) else code.substring(1).toInt()</b>
<b class="nc">&nbsp;            push(c)</b>
&nbsp;            return
&nbsp;        }
<b class="nc">&nbsp;        val result = when (code) {</b>
<b class="nc">&nbsp;            &quot;amp&quot; -&gt; &quot;&amp;&quot;</b>
<b class="nc">&nbsp;            &quot;apos&quot; -&gt; &quot;&#39;&quot;</b>
<b class="nc">&nbsp;            &quot;gt&quot; -&gt; &quot;&gt;&quot;</b>
<b class="nc">&nbsp;            &quot;lt&quot; -&gt; &quot;&lt;&quot;</b>
<b class="nc">&nbsp;            &quot;quot&quot; -&gt; &quot;\&quot;&quot;</b>
<b class="nc">&nbsp;            else -&gt; entityResolver(code)</b>
&nbsp;        }
<b class="nc">&nbsp;        unresolved = result == null</b>
<b class="nc">&nbsp;        if (result == null) {</b>
<b class="nc">&nbsp;            if (!token) error(&quot;unresolved: &amp;$code;&quot;)</b>
&nbsp;        } else {
<b class="nc">&nbsp;            for (i in 0 until result.length) push(result[i].code)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** types:
&nbsp;     * &#39;&lt;&#39;: parse to any token (for nextToken ())
&nbsp;     * &#39;&quot;&#39;: parse to quote
&nbsp;     * &#39; &#39;: parse to whitespace or &#39;&gt;&#39;
&nbsp;     */
&nbsp;    private fun pushText(delimiter: Int, resolveEntities: Boolean) {
<b class="nc">&nbsp;        var next = peek(0)</b>
<b class="nc">&nbsp;        var cbrCount = 0</b>
<b class="nc">&nbsp;        while (next != -1 &amp;&amp; next != delimiter) { // covers eof, &#39;&lt;&#39;, &#39;&quot;&#39;</b>
<b class="nc">&nbsp;            if (delimiter == &#39; &#39;.code) if (next &lt;= &#39; &#39;.code || next == &#39;&gt;&#39;.code) break</b>
<b class="nc">&nbsp;            if (next == &#39;&amp;&#39;.code) {</b>
<b class="nc">&nbsp;                if (!resolveEntities) break</b>
<b class="nc">&nbsp;                pushEntity()</b>
<b class="nc">&nbsp;            } else if (next == NEWLINE_CODE &amp;&amp; eventType === EventType.START_TAG) {</b>
<b class="nc">&nbsp;                read()</b>
<b class="nc">&nbsp;                push(&#39; &#39;.code)</b>
<b class="nc">&nbsp;            } else push(read())</b>
<b class="nc">&nbsp;            if (next == &#39;&gt;&#39;.code &amp;&amp; cbrCount &gt;= 2 &amp;&amp; delimiter != &#39;]&#39;.code) {</b>
<b class="nc">&nbsp;                error(&quot;Illegal: ]]&gt;&quot;)</b>
&nbsp;            }
<b class="nc">&nbsp;            if (next == &#39;]&#39;.code) cbrCount++ else cbrCount = 0</b>
<b class="nc">&nbsp;            next = peek(0)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun read(c: Char) {
<b class="nc">&nbsp;        val a = read()</b>
<b class="nc">&nbsp;        if (a != c.code) error(&quot;expected: &#39;&quot; + c + &quot;&#39; actual: &#39;&quot; + a.toChar() + &quot;&#39;&quot;)</b>
&nbsp;    }
&nbsp;
&nbsp;    // delegates to peek as peek handles cr/lf normalization.
&nbsp;    private fun read(): Int {
<b class="nc">&nbsp;        val result: Int</b>
<b class="nc">&nbsp;        if (peekCount == 0) result = peek(0) else {</b>
<b class="nc">&nbsp;            result = peek[0]</b>
<b class="nc">&nbsp;            peek[0] = peek[1]</b>
&nbsp;        }
&nbsp;        //		else {
&nbsp;        //			result = peek[0];
&nbsp;        //			System.arraycopy (peek, 1, peek, 0, peekCount-1);
&nbsp;        //		}
<b class="nc">&nbsp;        peekCount--</b>
<b class="nc">&nbsp;        columnNumber++</b>
<b class="nc">&nbsp;        if (result == NEWLINE_CODE) {</b>
<b class="nc">&nbsp;            lineNumber++</b>
<b class="nc">&nbsp;            columnNumber = 1</b>
&nbsp;        }
<b class="nc">&nbsp;        return result</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Does never read more than needed  */
&nbsp;    private fun peek(pos: Int): Int {
<b class="nc">&nbsp;        while (pos &gt;= peekCount) {</b>
<b class="nc">&nbsp;            val nw: Int = if (!source.hasNext()) -1 else source.nextChar().code</b>
<b class="nc">&nbsp;            if (nw == CARRIAGE_RETURN_CODE) {</b>
<b class="nc">&nbsp;                wasCR = true</b>
<b class="nc">&nbsp;                peek[peekCount++] = NEWLINE_CODE</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (nw == NEWLINE_CODE) {</b>
<b class="nc">&nbsp;                    if (!wasCR) {</b>
<b class="nc">&nbsp;                        peek[peekCount++] = NEWLINE_CODE</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    peek[peekCount++] = nw</b>
&nbsp;                }
<b class="nc">&nbsp;                wasCR = false</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return peek[pos]</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun readName(): String {
<b class="nc">&nbsp;        val pos = txtPos</b>
<b class="nc">&nbsp;        var c = peek(0)</b>
<b class="nc">&nbsp;        if ((c &lt; &#39;a&#39;.code || c &gt; &#39;z&#39;.code)</b>
<b class="nc">&nbsp;            &amp;&amp; (c &lt; &#39;A&#39;.code || c &gt; &#39;Z&#39;.code)</b>
<b class="nc">&nbsp;            &amp;&amp; c != &#39;_&#39;.code &amp;&amp; c != &#39;:&#39;.code &amp;&amp; c &lt; 0x0c0 &amp;&amp; !relaxed</b>
<b class="nc">&nbsp;        ) error(&quot;name expected&quot;)</b>
&nbsp;        do {
<b class="nc">&nbsp;            push(read())</b>
<b class="nc">&nbsp;            c = peek(0)</b>
<b class="nc">&nbsp;        } while (c &gt;= &#39;a&#39;.code &amp;&amp; c &lt;= &#39;z&#39;.code</b>
<b class="nc">&nbsp;            || c &gt;= &#39;A&#39;.code &amp;&amp; c &lt;= &#39;Z&#39;.code</b>
<b class="nc">&nbsp;            || c &gt;= &#39;0&#39;.code &amp;&amp; c &lt;= &#39;9&#39;.code</b>
<b class="nc">&nbsp;            || c == &#39;_&#39;.code || c == &#39;-&#39;.code || c == &#39;:&#39;.code || c == &#39;.&#39;.code || c &gt;= 0x0b7</b>
&nbsp;        )
<b class="nc">&nbsp;        val result = get(pos)</b>
<b class="nc">&nbsp;        txtPos = pos</b>
<b class="nc">&nbsp;        return result</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun skip() {
<b class="nc">&nbsp;        while (true) {</b>
<b class="nc">&nbsp;            val c = peek(0)</b>
<b class="nc">&nbsp;            if (c &gt; &#39; &#39;.code || c == -1) break</b>
<b class="nc">&nbsp;            read()</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // public part starts here...
&nbsp;
&nbsp;    override fun getNamespaceCount(depth: Int): Int {
<b class="nc">&nbsp;        if (depth &gt; this.depth) throw IndexOutOfBoundsException()</b>
<b class="nc">&nbsp;        return nspCounts[depth]</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun getNamespacePrefix(pos: Int): String {
<b class="nc">&nbsp;        return nspStack[pos shl 1]</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun getNamespaceUri(pos: Int): String {
<b class="nc">&nbsp;        return nspStack[(pos shl 1) + 1]</b>
&nbsp;    }
&nbsp;
&nbsp;    override val positionDescription: String
&nbsp;        get() {
<b class="nc">&nbsp;            val buf = StringBuilder(eventType.name)</b>
<b class="nc">&nbsp;            buf.append(&#39; &#39;)</b>
<b class="nc">&nbsp;            if (eventType == EventType.START_TAG || eventType == EventType.END_TAG) {</b>
<b class="nc">&nbsp;                if (isEmptyElementTag) {</b>
<b class="nc">&nbsp;                    buf.append(&quot;(empty) &quot;)</b>
&nbsp;                }
<b class="nc">&nbsp;                buf.append(&#39;&lt;&#39;)</b>
<b class="nc">&nbsp;                if (eventType == EventType.END_TAG) buf.append(&#39;/&#39;)</b>
<b class="nc">&nbsp;                if (prefix != &quot;&quot;) buf.append(&quot;{$namespace}$prefix:&quot;)</b>
<b class="nc">&nbsp;                buf.append(name)</b>
<b class="nc">&nbsp;                val cnt = attributeCount shl 2</b>
<b class="nc">&nbsp;                var i = 0</b>
<b class="nc">&nbsp;                while (i &lt; cnt) {</b>
<b class="nc">&nbsp;                    buf.append(&#39; &#39;)</b>
<b class="nc">&nbsp;                    if (attributes[i + 1] != &quot;&quot;) buf.append(&quot;{&quot; + attributes[i] + &quot;}&quot; + attributes[i + 1] + &quot;:&quot;)</b>
<b class="nc">&nbsp;                    buf.append(attributes[i + 2] + &quot;=&#39;&quot; + attributes[i + 3] + &quot;&#39;&quot;)</b>
<b class="nc">&nbsp;                    i += 4</b>
&nbsp;                }
<b class="nc">&nbsp;                buf.append(&#39;&gt;&#39;)</b>
<b class="nc">&nbsp;            } else if (eventType == EventType.IGNORABLE_WHITESPACE) {</b>
&nbsp;
<b class="nc">&nbsp;            } else if (eventType != EventType.TEXT) {</b>
<b class="nc">&nbsp;                buf.append(text)</b>
<b class="nc">&nbsp;            } else if (isWhitespace) buf.append(&quot;(whitespace)&quot;) else {</b>
<b class="nc">&nbsp;                var text = text</b>
<b class="nc">&nbsp;                if (text.length &gt; 16) text = text.substring(0, 16) + &quot;...&quot;</b>
<b class="nc">&nbsp;                buf.append(text)</b>
&nbsp;            }
<b class="nc">&nbsp;            buf.append(&quot;@$lineNumber:$columnNumber&quot;)</b>
<b class="nc">&nbsp;            return buf.toString()</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;    override val text: String
&nbsp;        get() {
<b class="nc">&nbsp;            return if (eventType &lt; EventType.TEXT</b>
<b class="nc">&nbsp;                || eventType == EventType.ENTITY_REF &amp;&amp; unresolved</b>
<b class="nc">&nbsp;            ) &quot;&quot; else get(0)</b>
&nbsp;        }
&nbsp;
&nbsp;    override fun getAttributeType(index: Int): String {
<b class="nc">&nbsp;        return &quot;CDATA&quot;</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun isAttributeDefault(index: Int): Boolean {
<b class="nc">&nbsp;        return false</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun getAttributeNamespace(index: Int): String {
<b class="nc">&nbsp;        if (index &gt;= attributeCount) throw IndexOutOfBoundsException()</b>
<b class="nc">&nbsp;        return attributes[index shl 2]</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun getAttributeName(index: Int): String {
<b class="nc">&nbsp;        if (index &gt;= attributeCount) throw IndexOutOfBoundsException()</b>
<b class="nc">&nbsp;        return attributes[(index shl 2) + 2]</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun getAttributePrefix(index: Int): String {
<b class="nc">&nbsp;        if (index &gt;= attributeCount) throw IndexOutOfBoundsException()</b>
<b class="nc">&nbsp;        return attributes[(index shl 2) + 1]</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun getAttributeValue(index: Int): String {
<b class="nc">&nbsp;        if (index &gt;= attributeCount) throw IndexOutOfBoundsException()</b>
<b class="nc">&nbsp;        return attributes[(index shl 2) + 3]</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun getAttributeValue(namespace: String, name: String): String? {
<b class="nc">&nbsp;        var i = (attributeCount shl 2) - 4</b>
<b class="nc">&nbsp;        while (i &gt;= 0) {</b>
<b class="nc">&nbsp;            if (attributes[i + 2] == name</b>
<b class="nc">&nbsp;                &amp;&amp; (namespace.isEmpty() || attributes[i].equals(namespace))</b>
<b class="nc">&nbsp;            ) return attributes[i + 3]</b>
<b class="nc">&nbsp;            i -= 4</b>
&nbsp;        }
<b class="nc">&nbsp;        return null</b>
&nbsp;    }
&nbsp;
&nbsp;    override operator fun next(): EventType {
<b class="nc">&nbsp;        txtPos = 0</b>
<b class="nc">&nbsp;        isWhitespace = true</b>
<b class="nc">&nbsp;        var minType = EventType.XML_DECL</b>
<b class="nc">&nbsp;        token = false</b>
&nbsp;        do {
<b class="nc">&nbsp;            nextImpl()</b>
<b class="nc">&nbsp;            if (eventType &lt; minType) {</b>
<b class="nc">&nbsp;                minType = eventType</b>
&nbsp;            }
<b class="nc">&nbsp;        } while (minType &gt; EventType.ENTITY_REF // ignorable</b>
<b class="nc">&nbsp;            || minType &gt;= EventType.TEXT &amp;&amp; peekType() &gt;= EventType.TEXT</b>
&nbsp;        )
<b class="nc">&nbsp;        eventType = minType</b>
<b class="nc">&nbsp;        if (eventType &gt; EventType.TEXT) {</b>
<b class="nc">&nbsp;            eventType = EventType.TEXT</b>
&nbsp;        }
<b class="nc">&nbsp;        return eventType</b>
&nbsp;    }
&nbsp;
&nbsp;    override fun nextToken(): EventType {
<b class="nc">&nbsp;        isWhitespace = true</b>
<b class="nc">&nbsp;        txtPos = 0</b>
<b class="nc">&nbsp;        token = true</b>
<b class="nc">&nbsp;        nextImpl()</b>
<b class="nc">&nbsp;        return eventType</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-07-22 15:26</div>
</div>
</body>
</html>
